package mq.radar.cinrad.decoders.cinrad;

import java.io.IOException;
import java.util.ArrayList;

import mq.radar.cinrad.decoders.DecodeException;
import mq.radar.cinrad.decoders.StreamingProcess;

import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Point;

/**
 * Decodes NHI NEXRAD Level-III Hail Index alphanumeric product.
 * 
 * From 2620003J.pdf 19.1:
 * 
 * "This product shall provide, for each storm cell identified by the Storm Cell
 * Identification and Tracking algorithm, the Probability of Hail, the
 * Probability of Severe Hail, and the Maximum Expected Hail Size. The hail
 * probabilities and size shown for each storm cell shall be generated by the
 * Hail Algorithm. This product shall be produced in a tabular format of
 * alphanumeric values, as a stand alone graphic product, and in a format for
 * generating graphic overlays to other products. This product shall include a
 * standard set of annotations. Upon user request, all site adaptable parameters
 * identified as inputs to the algorithm(s) used to generate data for this
 * product shall be available at the alphanumeric display."
 * 
 */
public class DecodeHail extends BaseCindarDecoder {
	private final Logger logger = LoggerFactory.getLogger(DecodeHail.class);

	private MathTransform cinradTransform;

	/**
	 * Constructor
	 * 
	 * @param header
	 *            Description of the Parameter
	 * @throws IOException
	 * @throws FactoryException
	 */
	public DecodeHail(CinradHeader header) throws DecodeException, IOException,
			FactoryException {
		super(header);
		this.decoderName = "DecodeHail";
	}

	@Override
	public String getDefaultSymbol() {
		return org.geotools.styling.StyleBuilder.MARK_TRIANGLE;
	}

	@Override
	public void decodeData(StreamingProcess[] processArray, boolean autoClose)
			throws DecodeException, IOException {
		try {
			cinradTransform = MQProjections.getInstance().getRadarTransform(
					header);
		} catch (FactoryException e1) {
			logger.error("FactoryException", e1);
			throw new DecodeException("PROJECTION TRANSFORM ERROR",
					header.getCinradURL());
		}

		SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
		{
			builder.setCRS(crs);
			builder.setName("Hail Data");
			builder.add("geom", Point.class);
			builder.nillable(true).length(5).add("wsrid", Integer.class);
			builder.nillable(true).length(15).add("datetime", String.class);
			builder.nillable(true).length(10).add("lat", Double.class);
			builder.nillable(true).length(10).add("lon", Double.class);
			builder.nillable(true).length(3).add("id", String.class);
			builder.nillable(true).length(7).add("range", Double.class);
			builder.nillable(true).length(7).add("azim", Double.class);
			builder.nillable(true).length(5).add("sevprob", String.class);
			builder.nillable(true).length(5).add("prob", String.class);
			builder.nillable(true).length(5).add("maxsize", String.class);
			schema = builder.buildFeatureType();
		}

		// Reset feature index counter
		int geoIndex = 0;

		// Decode the text blocks (block 2 and 3)
		DecodeAlphaGeneric decoder = new DecodeAlphaGeneric();
		decoder.decode(header);

		logger.info("----------- VERSION: " + header.getVersion()
				+ " ------------ \n");
		logger.info("----------- BLOCK 2 ----------- \n"
				+ decoder.getBlock2Text());
		logger.info("----------- BLOCK 3 ----------- \n"
				+ decoder.getBlock3Text());

		// Build text for block 2 data
		StringBuffer sb = new StringBuffer();
		sb.append("  HAIL INDEX SUPPLEMENTAL DATA 1\n\n");
		sb.append("  ABBREVIATIONS:\n");
		sb.append("  AZ    = Azimuth Angle From Radar \n");
		sb.append("          (In Degrees where 0 deg = North, 90 = East, 180 = South, etc...)\n");
		sb.append("  RAN   = Range (Distance) From Radar (In Nautical Miles (nmi))\n");
		sb.append("  POSH  = Probability of Severe Hail\n");
		sb.append("  POH   = Probability of Hail\n");
		sb.append("  MAX HAIL SIZE = Size in inches (in)\n\n");
		if (decoder.getBlock2Text() != null) {
			sb.append(decoder.getBlock2Text());
		} else {
			supplementalData[0] = " NO HAIL FEATURES PRESENT";
		}
		sb.append("\n\n");
		supplementalData[0] = sb.toString();

		// Build text for block 3 data
		sb = new StringBuffer();
		sb.append("  HAIL INDEX SUPPLEMENTAL DATA 2\n\n");
		if (decoder.getBlock3Text() != null) {
			sb.append(decoder.getBlock3Text());
		} else {
			supplementalData[0] = " PARAMETER DATA NOT PRESENT";
		}
		sb.append("\n\n");
		supplementalData[1] = sb.toString();

		String block2Text = decoder.getBlock2Text();
		String[] lines = (block2Text == null) ? new String[0] : block2Text
				.split("\n");

		logger.info("lines.length = " + lines.length);

		// Build text for block 3 data

		// Decode block 2 data into features

		if (lines.length == 0) {
			metaLabelString[0] = "NO HAIL PRESENT";
			return;
		}

		// Set up vectors to hold data until the data is fully read
		ArrayList<String> ids = new ArrayList<String>();
		ArrayList<Double> lats = new ArrayList<Double>();
		ArrayList<Double> lons = new ArrayList<Double>();
		ArrayList<Double> ranges = new ArrayList<Double>();
		ArrayList<Double> azims = new ArrayList<Double>();
		ArrayList<String> sevprobs = new ArrayList<String>();
		ArrayList<String> probs = new ArrayList<String>();
		ArrayList<String> maxsizes = new ArrayList<String>();
		ArrayList<Coordinate> coords = new ArrayList<Coordinate>();

		int hitCount = 0;
		int numEntries = 6;

		if (header.getVersion() > 1.0) {
			throw new DecodeException("UNKNOWN NEXRAD HAIL FILE VERSION: "
					+ header.getVersion(), header.getCinradURL());
		}

		for (int i = 0; i < lines.length; i++) {

			String str = lines[i];

			// skip empty lines
			if (lines[i].trim().length() == 0) {
				continue;
			}

			// ----------- VERSION 0 -----------------
			// 0 1 2 3 4 5 6 7
			// 01234567890123456789012345678901234567890123456789012345678901234567890
			// STORM ID Q T
			// AZ RAN 96 126 123 111
			// HAIL IND PROBABLE POSITIVE

			// STORM ID 59 28 57 52 58
			// AZ RAN 58 162 75 58 46 70 59 121 33 111
			// HAIL IND NONE POSITIVE POSITIVE NONE NONE
			if (header.getVersion() == 0) {
				logger.info("hitCount=" + hitCount + " ::: " + str);

				// Extract geodata
				if (hitCount == 0) {
					try {
						for (int n = 0; n < numEntries; n++) {
							String idText = str.substring(18 + n * 10,
									20 + n * 10);
							if (idText.trim().length() > 0) {
								ids.add(idText);
								logger.info("ADDING ID: "
										+ str.substring(18 + n * 10,
												20 + n * 10));
							} else {
								numEntries = n;
								logger.info("SETTING numEntries=" + numEntries);
							}
						}
					} catch (Exception e) {
						logger.info("CAUGHT DECODEHAIL EXCEPTION 1");
					}
				} else if (hitCount == 1) {
					try {
						for (int n = 0; n < numEntries; n++) {
							azims.add(new Double(str.substring(12 + n * 10,
									15 + n * 10)));
							ranges.add(new Double(str.substring(17 + n * 10,
									20 + n * 10)));

							double localrange = ((Double) ranges.get(ranges
									.size() - 1)).doubleValue();
							double localazim = ((Double) azims
									.get(azims.size() - 1)).doubleValue();
							// Correct for an azim of 0
							if (localazim == 0.0 || localazim == 180.0
									|| localazim == 360.0) {
								localazim += 0.000001;
							}

							// Coordinate coordinateSrc= new
							// Coordinate(localrange
							// * Math.sin(Math.toRadians(localazim))
							// * 1852.0, localrange
							// * Math.cos(Math.toRadians(localazim))
							// * 1852.0);
							double[] srcPts = {
									localrange
											* Math.sin(Math
													.toRadians(localazim))
											* 1852.0,
									localrange
											* Math.cos(Math
													.toRadians(localazim))
											* 1852.0 };
							double[] dstPts = new double[2];
							cinradTransform.transform(srcPts, 0, dstPts, 0, 1);
							Coordinate coordinate = new Coordinate(dstPts[0],
									dstPts[1]);
							coords.add(coordinate);
							lats.add(coordinate.y);
							lons.add(coordinate.x);

							logger.info("ADDING COORDINATE: (" + (n + 1) + "/"
									+ numEntries + ") " + coordinate.toString());
						}
					} catch (Exception e) {
						e.printStackTrace();
						logger.error("CAUGHT DECODEHAIL EXCEPTION 2");
					}
				} else if (hitCount == 2) {
					try {
						for (int n = 0; n < numEntries; n++) {
							sevprobs.add("N/A");
							probs.add(str.substring(10 + n * 10, 20 + n * 10));
							maxsizes.add("N/A");

							logger.info("ADDING PROB: "
									+ str.substring(10 + n * 10, 20 + n * 10));
						}
					} catch (Exception e) {
						logger.info("CAUGHT DECODEHAIL EXCEPTION 3");
					}
				}
				if (str.trim().length() > 0) {
					hitCount++;
				}

				// reset hitCount
				if (hitCount == 3) {
					hitCount = 0;
				}

			}// end if
				// ----------- VERSION 1 -----------------
				// 0 1 2 3 4 5 6 7
				// 01234567890123456789012345678901234567890123456789012345678901234567890
				// STORM ID D2 L4 Q1 V1 D1 W3
				// AZ/RAN 339/ 70 286/ 82 290/ 89 309/ 80 312/ 77 9/ 71
				// POSH/POH 0/ 0 0/ 0 0/ 0 0/ 0 0/ 0 0/ 0
				// MAX HAIL SIZE 0.00 0.00 0.00 0.00 0.00 0.00
				// 0/-20 C TEMP ALT 10.5/20.0 KFT(MSL) - LAST CHANGED 13:22
				// 11/10/02

			else if (header.getVersion() == 1) {

				logger.info("hitCount=" + hitCount + " ::: " + str);

				// Extract geodata
				if (hitCount == 0) {
					try {
						for (int n = 0; n < numEntries; n++) {
							String idText = str.substring(22 + n * 9,
									24 + n * 9);
							if (idText.trim().length() > 0) {
								ids.add(idText);
								logger.info("ADDING ID: "
										+ str.substring(22 + n * 9, 24 + n * 9));
							} else {
								numEntries = n;
								logger.info("SETTING numEntries=" + numEntries);
							}
						}
					} catch (Exception e) {
						logger.error("CAUGHT DECODEHAIL EXCEPTION 1");
					}
				} else if (hitCount == 1) {
					try {
						for (int n = 0; n < numEntries; n++) {
							azims.add(new Double(str.substring(17 + n * 9,
									20 + n * 9)));
							ranges.add(new Double(str.substring(21 + n * 9,
									24 + n * 9)));

							double localrange = ((Double) ranges.get(ranges
									.size() - 1)).doubleValue();
							double localazim = ((Double) azims
									.get(azims.size() - 1)).doubleValue();
							// Correct for an azim of 0
							if (localazim == 0.0 || localazim == 180.0
									|| localazim == 360.0) {
								localazim += 0.000001;
							}

							double[] srcPts = {
									localrange
											* Math.sin(Math
													.toRadians(localazim))
											* 1852.0,
									localrange
											* Math.cos(Math
													.toRadians(localazim))
											* 1852.0 };
							double[] dstPts = new double[2];
							cinradTransform.transform(srcPts, 0, dstPts, 0, 1);

							Coordinate coordinate = new Coordinate(dstPts[0],
									dstPts[1]);
							coords.add(coordinate);
							lats.add(coordinate.y);
							lons.add(coordinate.x);

							logger.info("ADDING COORDINATE: "
									+ coordinate.toString());
						}
					} catch (Exception e) {
						e.printStackTrace();
						logger.info("CAUGHT DECODEHAIL EXCEPTION 2");
					}
				} else if (hitCount == 2) {
					try {
						for (int n = 0; n < numEntries; n++) {
							String sevprob = str.substring(17 + n * 9,
									20 + n * 9);
							String prob = str.substring(21 + n * 9, 24 + n * 9);
							if (sevprob.trim().toUpperCase().equals("UNK"))
								sevprob = "N/A";
							if (prob.trim().toUpperCase().equals("OWN"))
								prob = "N/A";
							sevprobs.add(sevprob);
							probs.add(prob);

							logger.info("ADDING SEVPROB: "
									+ str.substring(17 + n * 9, 20 + n * 9));
							logger.info("ADDING PROB: "
									+ str.substring(21 + n * 9, 24 + n * 9));
						}
					} catch (Exception e) {
						logger.error("CAUGHT DECODEHAIL EXCEPTION 3");
					}
				} else if (hitCount == 3) {
					try {
						for (int n = 0; n < numEntries; n++) {
							String maxsize = str.substring(19 + n * 9,
									24 + n * 9);
							if (maxsize.trim().toUpperCase().equals("KNOWN"))
								maxsize = "N/A";
							maxsizes.add(maxsize);
							logger.info("ADDING MAXSIZES: "
									+ str.substring(19 + n * 9, 24 + n * 9));
						}
					} catch (Exception e) {
						logger.info("CAUGHT DECODEHAIL EXCEPTION 4");
					}
				}
				if (str.trim().length() > 0) {
					hitCount++;
				}

				// reset hitCount and skip a line
				if (hitCount == 4) {
					hitCount = 0;
					i++;
				}
			} else {
				throw new DecodeException("UNKNOWN NEXRAD HAIL FILE VERSION: "
						+ header.getVersion(), header.getCinradURL());
			}

		}// end for

		logger.info("ids.size() = " + ids.size());
		logger.info("lats.size() = " + lats.size());
		logger.info("lons.size() = " + lons.size());
		logger.info("coords.size() = " + coords.size());
		logger.info("ranges.size() = " + ranges.size());
		logger.info("azims.size() = " + azims.size());
		logger.info("sevprobs.size() = " + sevprobs.size());
		logger.info("probs.size() = " + probs.size());
		logger.info("maxsizes.size() = " + maxsizes.size());

		// Extract values and add to feature collection
		for (int n = 0; n < ids.size(); n++) {
			try {
				// create the feature

				SimpleFeature feature = SimpleFeatureBuilder.build(
						schema,
						new Object[] { geoFactory.createPoint(coords.get(n)),
								header.getRadarStationID(), datetime,
								lats.get(n), lons.get(n), ids.get(n).trim(),
								ranges.get(n), azims.get(n),
								sevprobs.get(n).trim(), probs.get(n).trim(),
								maxsizes.get(n).trim() }, new Integer(
								geoIndex++).toString());

				// add to streaming processes
				for (int s = 0; s < processArray.length; s++) {
					processArray[s].addFeature(feature);
				}
				// logger.info("ADDED FEATURE: "+feature);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		makeMetaLabelStrings();

	}

	private void makeMetaLabelStrings() {

		SimpleFeatureIterator fi = features.features();
		if (fi.hasNext()) { // only use first and thus strongest reading
			SimpleFeature f = fi.next();

			String id = f.getAttribute("id").toString().trim();
			String prob = f.getAttribute("prob").toString().trim();
			String size = f.getAttribute("maxsize").toString().trim();

			metaLabelString[0] = "MAX ID: " + id;
			metaLabelString[1] = "PROB: " + prob
					+ (prob.equals("N/A") ? "" : "%");
			metaLabelString[2] = "MAX SIZE: " + size
					+ (size.equals("N/A") ? "" : " in");
		} else {
			metaLabelString[0] = "NO HAIL PRESENT";
		}

	}

}
